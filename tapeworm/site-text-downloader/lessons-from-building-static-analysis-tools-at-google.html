<!doctype html>
<html xmlns:fb="http://ogp.me/ns/fb#">
<!--[if lt IE 7]><html class="no-js ie6 oldie" lang="en"><![endif]-->
<!--[if IE 7]><html class="no-js ie7 oldie" lang="en"><![endif]-->
<!--[if IE 8]><html class="no-js ie8 oldie" lang="en"><![endif]-->
<!--[if gt IE 8]><!--><html class="newie no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8" />

<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><![endif]-->
<!--[if lt IE 7]><html class="no-js ie6 oldie" lang="en"><![endif]-->
<!--[if IE 7]><html class="no-js ie7 oldie" lang="en"><![endif]-->
<!--[if IE 8]><html class="no-js ie8 oldie" lang="en"><![endif]-->
<!--[if gt IE 8]><!--><html class="newie no-js" lang="en"><!--<![endif]-->
<title>Lessons from Building Static Analysis Tools at Google | April 2018 | Communications of the ACM</title>
<meta name="title" content="Lessons from Building Static Analysis Tools at Google" />
<meta name="author" content="Caitlin Sadowski, Edward Aftandilian, Alex Eagle, Liam Miller-Cushon, Ciera Jaspan" />
<meta name="date" content="2018-4-1" />
<meta name="year" content="2018" />
<meta name="subjects" content="artificial intelligence,computer systems,hardware,management,performance and reliability,software,theory" />
<meta name="sections" content="Contributed Articles" />
<link rel="alternate" type="application/rss+xml" href="/magazine.rss" title="Communications of the ACM: Current Issue [RSS 2.0]" />
<link rel="canonical" href="https://cacm.acm.org/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google/fulltext" />
<link href="/stylesheets/all.css" rel="stylesheet" />
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>

<link href="/stylesheets/jplayer.pink.flag.css" rel="stylesheet" />
<link href="/stylesheets/sections/videos.css" rel="stylesheet" />
<link href="/stylesheets/tipsy.css" rel="stylesheet" />
<link href="/stylesheets/colorbox.css" rel="stylesheet" />
<script type="text/javascript" src="/javascripts/cookie.js"></script>
<script src="/javascripts/modernizr.js"></script>
<style>
      html{overflow: auto !important;}
    </style>
<meta property="og:type" content="article" /><meta property="og:url" content="https://cacm.acm.org/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google/fulltext" /><meta property="og:title" content="Lessons from Building Static Analysis Tools at Google" /><meta property="og:image" content="https://cacm.acm.org/system/assets/0003/0646/032118_CACMpg58_Lessons-from-Building.large.jpg?1521731111&amp;1521731110" /><meta property="og:description" content="For a static analysis project to succeed, developers must feel they benefit from and enjoy using it.
" />
<script type="text/javascript" src="https://s7.addthis.com/js/250/addthis_widget.js#pubid=xa-4dcbeff2515fc93c"></script>
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','F_pTME7mydky5kHVQaaa','2.0.0');
</script>
<script type="text/javascript">
  window.onload = function() {
    $("a[href*='dlsearch']").click(function(event) {
      if (location.hash) {
        event.preventDefault();

        var initialHref = $(event.target).attr('href').replace('query=&', "").replace('query=', "");

        var query = location.hash.substring(1).split("&")

        if (query) {
          query = query.find(function(e) { return e.indexOf("stq=") !== -1 })

          if (query) {
            query = query.substring(4);
          }
        }

        query = initialHref + "&query=" + query;

        window.location.href = query;
      }
    });
  }
</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-6995646-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-6995646-3');
</script>
<meta property="og:type" content="article" /><meta property="og:url" content="https://cacm.acm.org/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google/fulltext" /><meta property="og:title" content="Lessons from Building Static Analysis Tools at Google" /><meta property="og:image" content="https://cacm.acm.org/system/assets/0003/0646/032118_CACMpg58_Lessons-from-Building.large.jpg?1521731111&amp;1521731110" /><meta property="og:description" content="For a static analysis project to succeed, developers must feel they benefit from and enjoy using it.
" />
</head>
<body id="body-main" itemscope itemtype="http://schema.org/Article">
<div id='domain-info' data-domain='cacm.acm.org'></div>
<div class="JumpLink" id="PageTop"></div>
<div id="container">
<div id="layout">
<header class="topHeader">
<a href="/" title="ACM" id="topLogo">ACM</a>
<div id="instName"><img src="/images/icons/acm_header.png" height="40" width="40" class="logo-mini" /></div>
<a href="/login" title="Login" id="topSignIn">Sign In</a>
<div id="topForm">
<form action="/search" method="get">
<div class="portaInput">
<label for="searchInput" id="labelSearchInput" class="inField"></label>
<input type="text" id="searchInput" class="st-default-search-input" placeholder="Search" name="q" />
</div>
<button name="search submit" type="submit" id="searchSubmit">Go</button>
</form>
</div>
<div id="topBar">
<ul>
<li><a href="https://www.acm.org/" title="ACM.org">ACM.org</a></li>
<li><a href="https://campus.acm.org/public/qj/brandingqj/cacm.cfm" target="_blank" title="Join ACM">Join ACM</a></li>
<li><a href="/about-communications" title="About Communications">About Communications</a></li>
<li><a href="/acm-resources" title="ACM Resources">ACM Resources</a></li>
<li class="last-child"><a href="/alerts-and-feeds" title="Alerts &#38; Feeds">Alerts &#38; Feeds</a></li>
<li class="last-child">
<a href="https://www.facebook.com/Communications-of-the-ACM-521319564596131/" style="margin: 0;padding: 0;margin-right: 1px;margin-top: -2px;"><img src="/images/icons/facebook.png" style="height: 18px;width: 18px;"></a>
<a href="https://twitter.com/cacmmag" style="margin: 0;padding: 0;margin-top: -1px;margin-right: 4px;"><img src="/images/icons/twitter.png" style="width: 16px;height: 16px;"></a>
<a href="/alerts-and-feeds/rss-feeds" style="margin: 0;padding: 0;"><img src="/images/icons/rss.png" style="width: 14px;height: 14px;"></a>
</li>
</ul>
</div>
<hgroup>
<h1><a href="/" title="Communications of the ACM">Communications of the ACM</a></h1>
</hgroup>
<nav>
<ul>
<li class="first-child"><a href="/" class="menuText itemHome">Home</a></li>
<li>
<div class="portaDropdown">
<a class="withMenu menuText itemCurrent" href="/magazines/2021/3">Current Issue</a>
<div class="menuLinks currenIssueDropdown">
<a class="menuCover" href="/magazines/2021/3">
<img src="https://cacm.acm.org/system/assets/0003/9234/March2021.Cover.500x669.large.jpg?1613515043&1613515043" width="145" height="192" alt="Latest issue" />
</a>
<span class="dropDownIssueTitle">Current Issue: March 2021</span>
<a href="/magazines/2021/3/250710-the-decline-of-computers-as-a-general-purpose-technology">The Decline of Computers as a General Purpose Technology</a>
<a href="/magazines/2021/3/250705-50-years-of-pascal">50 Years of Pascal</a>
<a href="/magazines/2021/3/250712-cyber-reconnaissance-techniques">Cyber Reconnaissance Techniques</a>
<a class="lastLink" href="/magazines/2021/3">VIEW TABLE OF CONTENTS</a>
</div>
</div>
</li>
<li>
<div class="portaDropdown">
<a href="/news" class="withMenu menuText itemNews">News</a>
<div class="menuLinks newsDropdown">
<a href="/news" class="lastLink">Latest News</a>
<a href="/news/archive" class="lastLink">News Archive</a>
</div>
</div>
</li>
<li>
<div class="portaDropdown">
<a href="/blogs/about-the-blogs" class="withMenu menuText itemBlogs">Blogs</a>
<div class="menuLinks blogsDropdown">
<a href="/blogs/about-the-blogs">About the Blogs</a>
<a href="/blogs/blog-cacm">BLOG@CACM</a>
<a href="/blogs/blogroll">Blogroll</a>
<a href="/blogs/archive" class="lastLink">Blogs Archive</a>
</div>
</div>
</li>
<li>
<div class="portaDropdown">
<a href="/opinion" class="withMenu menuText itemOpinion">Opinion</a>
<div class="menuLinks opinionDropdown">
<a href="/opinion/articles">Articles</a>
<a href="/opinion/interviews">Interviews</a>
<a href="/opinion/archive" class="lastLink">Opinion Archive</a>
</div>
</div>
</li>
<li>
<div class="portaDropdown">
<a href="/research" class="withMenu menuText itemResearch">Research</a>
<div class="menuLinks researchDropdown">
<a href="/research">Latest Research</a>
<a href="/research/archive" class="lastLink">Research Archive</a>
</div>
</div>
</li>
<li>
<div class="portaDropdown">
<a href="/practice" class="withMenu menuText itemPractice">Practice</a>
<div class="menuLinks practiceDropdown">
<a href="/practice">Latest Practice</a>
<a href="/practice/archive" class="lastLink">Practice Archive</a>
</div>
</div>
</li>
<li>
<div id="careersNav" class="portaDropdown">
<a href="/careers" class="withMenu menuText itemOpinion">Careers</a>
<div class="menuLinks opinionDropdown">
<ul>
<li><a href="http://jobs.acm.org/jobs/search/results?rows=15&radius=0&view=List_Detail&sort=score+desc" target="_blank">Search for Jobs</a></li>
<li><a href="http://jobs.acm.org/jobs/resumes/create" target="_blank">Post a Resume</a></li>
<li><a href="http://jobs.acm.org/jobs/products" target="_blank">Post A Job</a></li>
<li><a href="https://www.acm.org/publications/advertising" target="_blank">Advertise with Us</a></li>
<li class="lastLink"><a href="mailto:careers@acm.org">Contact Us</a></li>
</ul>
</div>
</div>
</li>
<li>
<div class="portaDropdown">
<a href="/magazines" class="withMenu menuText itemPrevious on">Archive</a>
<div class="menuLinks previousDropdown">
<span class="previousIssueTitle">The magazine archive includes every article published in <i>Communications of the ACM</i> for over the past 50 years.</span>
<div class="issue">
<a href="/magazines/2021/3">
March 2021 (Vol. 64, No. 3)
</a>
</div>
<div class="issue">
<a href="/magazines/2021/2">
February 2021 (Vol. 64, No. 2)
</a>
</div>
<div class="issue">
<a href="/magazines/2021/1">
January 2021 (Vol. 64, No. 1)
</a>
</div>
<a href="/magazines" class="lastLink">VIEW MORE ISSUES</a>
</div>
</div>
</li>
<li>
<a href="/videos" class="menuText itemVideos">Videos</a>
</li>
</ul>
</nav>
</header>
<section>
<script type="text/javascript" src="https://s7.addthis.com/js/250/addthis_widget.js#pubid=xa-4dcbeff2515fc93c"></script>
<div class="breadcrum">
<a href="/">Home</a><span>/</span><a href="/magazines/decade">Magazine Archive</a><span>/</span><a href='/magazines/2018/4'>April 2018 (Vol. 61, No. 4)</a><span>/</span><a href="/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google">Lessons from Building Static Analysis Tools at Google</a><span>/</span>Full Text
</div>
<div class="col0 floatLeft firstCol">
<span class="label">Contributed articles</span>
<h1>Lessons from Building Static Analysis Tools at Google</h1>
<h6 class="subheader"></h6>
</div>
<hr class="dotted" />
<div id="articleFullText" class="col1 floatLeft firstCol">
<span class="byline">
By Caitlin Sadowski, Edward Aftandilian, Alex Eagle, Liam Miller-Cushon, Ciera Jaspan
<br />
Communications of the ACM,
April 2018,
Vol. 61 No. 4, Pages 58-66<br />
10.1145/3188720<br />
<a href="#comments">Comments</a>
</span>

<div class="fav_bar">
<style>
    .fav_hacker_news {
      background:url('https://img.icons8.com/color/48/000000/hacker-news.png') no-repeat center #FFF;
      background-size: 21.5px;
    }
    .fav_hacker_news:hover {
      background:url('https://img.icons8.com/color/48/000000/hacker-news.png') no-repeat center #e6e9ea;
      background-size: 21.5px;
    }
    .fav_bar a.fav_reddit {
      background-size: 22px;
      background:url('https://cacm.acm.org/images/icons/reddit.gif') no-repeat center #FFF;
    }
    .fav_bar a.fav_reddit:hover {
      background-color: #e6e9ea;
    }
    .fav_bar a.fav_facebook {
      background-size: 22px;
      background:url('https://cacm.acm.org/images/icons/facebook.gif') no-repeat center #FFF;
    }
    .fav_bar a.fav_facebook:hover {
      background-color: #e6e9ea;
      background:url('https://cacm.acm.org/images/icons/facebook.gif') no-repeat center #e6e9ea;
    }
  </style>
<span>View as:</span>
<a href="#" onclick="javascript:window.print();" class="fav_print" title="Print">Print</a>
<a href="/about-communications/mobile-apps/" class="mobile-apps" title="MOBILE APPS">Mobile App</a>
<a href="https://dl.acm.org/citation.cfm?id=3200906.3188720&amp;coll=portal&amp;dl=ACM" class="fav_acm_digital" target="_blank" title="View in ACM Digital Library">ACM Digital Library</a>
<a href="/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google/pdf" class="fav_pdf" rel="nofollow" target="_blank" title="View as PDF">Full Text (PDF)</a>
<a href="https://dl.acm.org/ft_gateway.cfm?id=3188720&ftid=1954717&dwn=1" class="fav_de" target="_blank" title="View in Digital Edition">In the Digital Edition</a>
<span>Share:</span>
<a href="javascript:void(0);" class="fav_email" title="Send by email" id="sendByEmail">Send by email</a>
<a href="javascript:void(0);" class="fav_reddit" onClick="addthis_sendto('reddit');" title="Share on reddit">Share on reddit</a>
<a href="javascript:void(0);" class="fav_su" onClick="addthis_sendto('stumbleupon');" title="Share on StumbleUpon">Share on StumbleUpon</a>
<a href="https://news.ycombinator.com/" class="fav_hacker_news" title="Share on Hacker News">Share on Hacker News</a>
<a href="javascript:void(0);" class="fav_twitter" onClick="addthis_sendto('twitter');" title="Share on Twitter">Share on Tweeter</a>
<a href="javascript:void(0);" class="fav_facebook" onClick="addthis_sendto('facebook');" title="Share on Facebook">Share on Facebook</a>
<div class="addthis_toolbox ">
<a href="https://www.addthis.com/bookmark.php?v=250&amp;pubid=xa-4dcbeff2515fc93c" class="addthis_button_compact fav_more no_border">Share</a>
</div>
<script type="text/javascript" src="https://s7.addthis.com/js/250/addthis_widget.js#pubid=xa-4dcbeff2515fc93c"></script>
</div>

<div class="clearer"></div>
<div class='imageWithCaptionLeft' id='asset-30646'>
<figure>
<img alt='Lessons from Building Static Analysis Tools at Google, illustration' src='/system/assets/0003/0646/032118_CACMpg58_Lessons-from-Building.large.jpg?1521731111&amp;1521731110' title='Lessons from Building Static Analysis Tools at Google, illustration' />
<figcaption>
<p class='credit'>Credit: Igor Kisselev</p>
</figcaption>
</figure>
</div>

<a name="body-1"></a>
<p>Software bugs cost developers and software companies a great deal of time and money. For example, in 2014, a bug in a widely used SSL implementation (&quot;goto fail&quot;) caused it to accept invalid SSL certificates,<sup><a href="#R36">36</a></sup> and a bug related to date formatting caused a large-scale Twitter outage.<sup><a href="#R23">23</a></sup> Such bugs are often statically detectable and are, in fact, obvious upon reading the code or documentation yet still make it into production software.</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<a name="body-2"></a>
<h3>Key Insights</h3>
<p><img src="https://dl.acm.org/cms/attachment/be3cba73-5c49-435d-97cc-a4b00418dc8b/ins01.gif" border="0" hspace="5" vspace="5" alt="ins01.gif" /></p>
<p>Previous work has reported on experience applying bug-detection tools to production software.<sup><a href="#R6">6</a>,<a href="#R3">3</a>,<a href="#R7">7</a>,<a href="#R29">29</a></sup> Although there are many such success stories for developers using static analysis tools, there are also reasons engineers do not always use static analysis tools or ignore their warnings,<sup><a href="#R6">6</a>,<a href="#R7">7</a>,<a href="#R26">26</a>,<a href="#R30">30</a></sup> including:
</p>
<p><i>Not integrated.</i> The tool is not integrated into the developer's workflow or takes too long to run;</p>
<p><i>Not actionable.</i> The warnings are not actionable;</p>
<p><i>Not trustworthy.</i> Users do not trust the results due to, say, false positives;</p>
<p><i>Not manifest in practice.</i> The reported bug is theoretically possible, but the problem does not actually manifest in practice;</p>
<p><i>Too expensive to fix.</i> Fixing the detected bug is too expensive or risky; and</p>
<p><i>Warnings not understood.</i> Users do not understand the warnings.</p>
<p>Here, we describe how we have applied the lessons from Google's previous experience with FindBugs Java analysis, as well as from the academic literature, to build a successful static analysis infrastructure used daily by most software engineers at Google. Google's tooling detects thousands of problems per day that are fixed by engineers, by their own choice, before the problematic code is checked into Google's companywide codebase.</p>
<p><i>Scope.</i> We focus on static analysis tools that have become part of the core developer workflow at Google and used by a large fraction of Google's developers. Many of the static analysis tools deployed at the scale of Google's two-billion-line codebase<sup><a href="#R32">32</a></sup> are relatively simple; running more sophisticated analyses at scale is not yet considered a priority.</p>
<p>Note that developers outside of Google working in specialized fields (such as aerospace<sup><a href="#R13">13</a></sup> and medical devices<sup><a href="#R21">21</a></sup>) may use additional static analysis tools and workflows. Likewise, developers working on specific types of projects (such as kernel code and device drivers<sup><a href="#R4">4</a></sup>) may run ad hoc analyses. There has been lots of great work on static analysis, and we do not claim the lessons we report here are unique, but we do believe that collating and sharing what has worked to improve code quality and the developer experience at Google is valuable.</p>
<p><i>Terminology.</i> We use the following terms: analysis tools run one or more &quot;checks&quot; over source code and identify &quot;issues&quot; that may or may not represent actual software faults. We consider an issue to be an &quot;effective false positive&quot; if developers did not take positive action after seeing the issue.<sup><a href="#R35">35</a></sup> If an analysis incorrectly reports an issue, but developers make the fix anyway to improve code readability or maintainability, that is not an effective false positive. If an analysis reports an actual fault, but the developer did not understand the fault and therefore took no action, that is an effective false positive. We make this distinction to emphasize the importance of developer perception. Developers, not tool authors, will determine and act on a tool's perceived false-positive rate.</p>
<p><b>How Google builds software.</b> Here, we outline key aspects of Google's software-development process. At Google, nearly all developer tools (with the exception of the development environment) are centralized and standardized. Many parts of the infrastructure are built from scratch and owned by internal teams, giving the flexibility to experiment.</p>
<p><i>Source control and code ownership.</i> Google has developed and uses a single-source control system and a single monolithic source code repository that holds (nearly) all Google proprietary source code.<sup><a href="#FNA">a</a></sup> Developers use &quot;trunk-based&quot; development, with limited use of branches, typically for releases, not for features. Any engineer can change any piece of code, subject to approval by the code's owners. Code ownership is path-based; an owner of a directory implicitly owns all subdirectories as well.</p>
<p><i>Build system.</i> All code in Google's repository builds with a customized version of the Bazel build system,<sup><a href="#R5">5</a></sup> requiring that builds be hermetic; that is, all inputs must be explicitly declared and stored in source control so the builds are easily distributed and parallelized. In Google's build system, Java rules depend on the Java Development Kit and Java compiler that are checked into source control, and such binaries can be updated for all users simply by checking-in new versions. Builds are generally from source (at head), with few binary artifacts checked into the repository. Since all developers use the same build system, it is the source of truth for whether any given piece of code compiles without errors.</p>
<p><i>Analysis tools.</i> The static analysis tools Google uses are typically not complex. Google does not have infrastructure support to run interprocedural or whole-program analysis at Google scale, nor does it use advanced static analysis techniques (such as separation logic<sup><a href="#R7">7</a></sup>) at scale. Even simple checks have required analysis infrastructure supporting workflow integration to make them successful. The types of analyses deployed as part of the general developer workflow include:</p>
<p><i>Style checkers</i> (such as Checkstyle,<sup><a href="#R10">10</a></sup> Pylint,<sup><a href="#R34">34</a></sup> and Golint<sup><a href="#R18">18</a></sup>);</p>
<p><i>Bug-finding tools that may extend the compiler</i> (such as Error Prone,<sup><a href="#R15">15</a></sup> ClangTidy,<sup><a href="#R12">12</a></sup> Clang Thread Safety Analysis,<sup><a href="#R11">11</a></sup> Govet,<sup><a href="#R17">17</a></sup> and the Checker Framework<sup><a href="#R9">9</a></sup>), including, but not limited to, abstract-syntax-tree pattern-match tools, type-based checks, and unused variable analysis;</p>
<p><i>Analyzers that make calls to production services</i> (such as to check whether an employee mentioned in a code comment is still employed at Google); and</p>
<p><i>Analyzers that examine properties of build outputs</i> (such as the size of binaries).</p>
<p>The &quot;goto fail&quot; bug<sup><a href="#R36">36</a></sup> would have been caught by Google's C++ linter that checks whether if statements are followed by braces. The code that caused the Twitter outage<sup><a href="#R23">23</a></sup> would not compile at Google because of an Error Prone compiler error, a pattern-based check that identifies date-formatting misuses. Google developers also use dynamic analysis tools (such as AddressSanitizer) to find buffer overruns and ThreadSanitizer to find data races.<sup><a href="#R14">14</a></sup> These tools are run during testing and sometimes also with production traffic.</p>
<p><i>Integrated Development Environments (IDEs).</i> An obvious workflow integration point to show static analysis issues early in the development process is within an IDE. However, Google developers use a wide variety of editors, making it difficult to consistently detect bugs by all developers prior to invoking the build tool. Although Google does use analyses integrated with popular internal IDEs, requiring a particular IDE with analyses enabled is a non-starter.</p>
<p><i>Testing.</i> Nearly all Google code includes corresponding tests, ranging from unit tests all the way to large-scale integration tests. Tests are integrated as a first-class concept in the build system and hermetic and distributed, just like builds. For most projects, developers write and maintain the tests for their code; projects typically have no separate testing or quality-assurance group. Google's continuous build-and-test system runs tests on every commit and notifies a developer if the developer's change broke the build or caused a test to fail. It also supports testing a change before committing to avoid breaking downstream projects.</p>
<hr align="center" width="50%" />
<blockquote>
<p align="center"><i>Developers, not tool authors, will determine and act on a tool's perceived false-positive rate.</i></p>
</blockquote>
<hr align="center" width="50%" />
<p><i>Code review.</i> Every commit to Google's codebase goes through code review first. Although any developer can propose a change to any part of Google's code, an owner of the code must review and approve the change before submission. In addition, even owners must have their code reviewed before committing a change. Code review happens through a centralized, web-based tool that is tightly integrated with other development infrastructure. Static analysis results are surfaced in code review.</p>
<p><i>Releasing code.</i> Google teams release frequently, with much of the release validation and deployment process automated through a &quot;push on green&quot; methodology,<sup><a href="#R27">27</a></sup> meaning an arduous, manual-release-validation process is not possible. If Google engineers find a bug in a production service, a new release can be cut and deployed to production servers at relatively low cost compared with applications that must be shipped to users.</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<a name="body-3"></a>
<h3>What We Learned from FindBugs</h3>
<p>Earlier research, from 2008 to 2010, on static analysis at Google focused on Java analysis with FindBugs<sup><a href="#R2">2</a>,<a href="#R3">3</a></sup>: a stand-alone tool created by William Pugh of the University of Maryland and David Hovemeyer of York College of Pennsylvania that analyzes compiled Java class files and identifies patterns of code that lead to bugs. As of January 2018, FindBugs was available at Google only as a command-line tool used by few engineers. A small Google team, called &quot;BugBot,&quot; worked with Pugh on three failed attempts to integrate FindBugs into the Google developer workflow.</p>
<p>We have thus learned several lessons:</p>
<p><i>Attempt 1. Bug dashboard.</i> Initially, in 2006, FindBugs was integrated as a centralized tool that ran nightly over the entire Google codebase, producing a database of findings engineers could examine through a dashboard. Although FindBugs found hundreds of bugs in Google's Java codebase, the dashboard saw little use because a bug dashboard was outside the developers' usual workflow, and distinguishing between new and existing static-analysis issues was distracting.</p>
<p><i>Attempt 2. Filing bugs.</i> The BugBot team then began to manually triage new issues found by each nightly FindBugs run, filing bug reports for the most important ones. In May 2009, hundreds of Google engineers participated in a companywide &quot;Fixit&quot; week, focusing on addressing FindBugs warnings.<sup><a href="#R3">3</a></sup> They reviewed a total of 3,954 such warnings (42% of 9,473 total), but only 16% (640) were actually fixed, despite the fact that 44% of reviewed issues (1,746) resulted in a bug report being filed. Although the Fixit validated that many issues found by FindBugs were actual bugs, a significant fraction were not important enough to fix in practice. Manually triaging issues and filing bug reports is not sustainable at a large scale.</p>
<p><i>Attempt 3. Code review integration.</i> The BugBot team then implemented a system in which FindBugs automatically ran when a proposed change was sent for review, posting results as comments on the code-review thread, something the code-review team was already doing for style/formatting issues. Google developers could suppress false positives and apply FindBugs' confidence in the result to filter comments. The tooling further attempted to show only new FindBugs warnings but sometimes miscategorized issues as new. Such integration was discontinued when the code-review tool was replaced in 2011 for two main reasons: the presence of effective false positives caused developers to lose confidence in the tool, and developer customization resulted in an inconsistent view of analysis results.</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<a name="body-4"></a>
<h3>Make It a Compiler Workflow</h3>
<p>Concurrent with FindBugs experimentation, the C++ workflow at Google was improving with the addition of new checks to the Clang compiler. The Clang team implemented new compiler checks, along with suggested fixes, then used ClangMR<sup><a href="#R38">38</a></sup> to run the updated compiler in a distributed way over the entire Google codebase, refine checks, and programmatically fix all existing instances of a problem in the codebase. Once the codebase was cleansed of an issue, the Clang team enabled the new diagnostic as a compiler error (not a warning, which the Clang team found Google developers ignored) to break the build, a report difficult to disregard. The Clang team was very successful improving the codebase through this strategy.</p>
<p>We followed this design and built a simple pattern-based static analysis for Java called Error Prone<sup><a href="#R15">15</a></sup> on top of the javac Java compiler.<sup><a href="#R1">1</a></sup> The first check rolled out, called <code>PreconditionsCheckNotNull</code>,<sup><a href="#FNB">b</a></sup> detects cases in which a runtime precondition check trivially succeeds because the arguments in the method call are transposed, as when, say, <code>checkNotNull(&quot;uid was null&quot;, uid)</code> instead of <code>checkNotNull(uid, &quot;uid was null&quot;).</code></p>
<p>In order to launch checks like <code>PreconditionsCheckNotNull</code> without breaking any continuous builds, the Error Prone team runs such checks over the whole codebase using a javac-based MapReduce program, analogous to ClangMR, called JavacFlume built using FlumeJava.<sup><a href="#R8">8</a></sup> JavacFlume emits a collection of suggested fixes, represented as diffs, that are then applied to produce a whole-codebase change. The Error Prone team uses an internal tool, Rosie,<sup><a href="#R32">32</a></sup> to split the large-scale change into small changes that each affect a single project, test those changes, and send them for code review to the appropriate team. The team reviews only those fixes that apply to its code, and, when they approve them, Rosie commits the change. All changes are eventually approved, the existing issues are fixed, and the team enables the compiler error.</p>
<p>When we have surveyed developers who received these patches, 57% of them who received a proposed fix to checked-in code were happy to have received it, and 41% were neutral. Only 2% responded negatively, saying, &quot;It just created busywork for me.&quot;</p>
<p><b>Value of compiler checks.</b> Compiler errors are displayed early in the development process and integrated into the developer workflow. We have found expanding the set of compiler checks to be effective for improving code quality at Google. Because checks in Error Prone are self-contained and written against the javac abstract syntax tree, rather than bytecode (unlike FindBugs), it is relatively easy for developers outside the team to contribute checks. Leveraging these contributions is vital in increasing Error Prone's overall impact. As of January 2018, 733 checks had been contributed by 162 authors.</p>
<p><b>Reporting issues sooner is better.</b> Google's centralized build system logs all builds and build results, so we identified all users who had seen one of the error messages in a given time window. We sent a survey to developers who recently encountered a compiler error and developers who had received a patch with a fix for the same problem. Google developers perceive that issues flagged at compile time (as opposed to patches for checked-in code) catch more important bugs; for example, survey participants deemed 74% of the issues flagged at compile time as &quot;real problems,&quot; compared to 21% of those found in checked-in code. In addition, survey participants deemed 6% of the issues found at compiletime (vs. 0% in checked-in code) &quot;critical.&quot; This result is explained by the &quot;survivor effect&quot;;<sup><a href="#R3">3</a></sup> that is, by the time code is submitted, the errors are likely to have been caught by more expensive means (such as testing and code review). Moving as many checks into the compiler as possible is one proven way to avoid those costs.</p>
<p><b>Criteria for compiler checks.</b> To scale-up our work, we have defined criteria for enabling checks in the compiler, setting the bar high, since breaking the compile would be a significant disruption. A compiler check at Google should be easily understood; actionable and easy to fix (whenever possible, the error should include a suggested fix that can be applied mechanically); produce no effective false positives (the analysis should never stop the build for correct code); and report issues affecting only correctness rather than style or best practices.</p>
<p>The primary goal of an analyzer satisfying these criteria is not simply to detect faults but to automatically fix all instances of a prospective compiler error throughout the codebase. However, such criteria limit the scope of the checks the Error Prone team enables when compiling code; many issues that cannot always be detected correctly or mechanically fixed are still serious problems.</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<a name="body-5"></a>
<h3>Warn During Code Review</h3>
<p>Once the Error Prone team had built the infrastructure needed to detect issues at compile time, and had proved the approach works, we wanted to show more high-impact bugs that do not meet the criteria we outlined earlier for compiler errors and provide results for languages other than Java and C++. The second integration point for static analysis results is Google's code review tool, Critique; static analysis results are exposed in Critique using Tricorder,<sup><a href="#R35">35</a></sup> Google's program-analysis platform. As of January 2018, there was a compiler warnings-free default for C++ and Java builds at Google, with all analysis results either shown as compiler errors or in code review.</p>
<p><b>Criteria for code-review checks.</b> Unlike compile-time checks, analysis results shown during code review are allowed to include up to 10% effective false positives. There is an expectation during code review that feedback is not always perfect and that authors evaluate proposed changes before applying them. A code review check at Google should fulfill several criteria:</p>
<p><i>Be understandable.</i> Be easy for any engineer to understand;</p>
<p><i>Be actionable and easy to fix.</i> The fix may require more time, thought, or effort than a compiler check, and the result should include guidance as to how the issue might indeed be fixed;</p>
<p><i>Produce less than 10% effective false positives.</i> Developers should feel the check is pointing out an actual issue at least 90% of the time;<sup><a href="#FNC">c</a></sup> and</p>
<p><i>Have the potential for significant impact on code quality.</i> The issues may not affect correctness, but developers should take them seriously and deliberately choose to fix them.</p>
<p>Some issues are severe enough to be flagged in the compiler, but producing them or developing an automated fix is not feasible. For example, fixing an issue may require significant restructuring of the code. Enabling these checks as compiler errors would require manual cleanup of existing instances that is infeasible on the scale of Google's vast codebase. Analysis tools show these checks in code review prevent new occurrences of the issue, allowing the developer to decide how to make an appropriate fix. Code review is also a good context for reporting relatively less-important issues like stylistic problems or opportunities to simplify code. In our experience, reporting them at compile-time is frustrating for developers and makes it more difficult to iterate and debug quickly; for example, an unreachable code detector might hinder attempts to temporarily disable a block of code for debugging. However, at code-review time, developers are preparing their code to be seen; they are already in a critical mindset and more receptive to seeing readability and stylistic details.</p>
<p><b>Tricorder.</b> Tricorder is designed to be easily extensible and support many different kinds of program-analysis tools, including static and dynamic analyses. We showed a suite of Error Prone checks in Tricorder that cannot be enabled as compiler errors. Error Prone also inspired a new set of analyses for C++ that are integrated with Tricorder and called ClangTidy.<sup><a href="#R12">12</a></sup> Tricorder analyzers report results for more than 30 languages, support simple syntactic analyses like style checkers, leverage compiler information for Java, JavaScript, and C++, and are straightforward to integrate with production data (such as about jobs that are currently running). Tricorder continues to be successful at Google because it is a plug-in model supporting an ecosystem of analysis writers, actionable issues are highlighted during the codereview process, and it provides feedback channels to improve analyzers and ensure analyzer developers act on the feedback.</p>
<p><i>Empower users to contribute.</i> As of January 2018, Tricorder included 146 analyzers, with 125 contributed from outside the Tricorder team and seven plug-in systems for hundreds of additional checks (such as ErrorProne and ClangTidy, which comprise two of the seven analyzers plug-in systems).</p>
<p><i>Provide fixes and involve reviewers.</i> Tricorder checks can provide suggested fixes that can be directly applied from the code-review tool. They are seen by both the reviewer and the author, and the reviewer can ask the author to fix the problematic code simply by clicking a &quot;Please fix&quot; button on the analysis result. Reviewers typically withhold approval of a change until all their comments, manual and automated, have been addressed.</p>
<p><i>Iterate on feedback from users.</i> In addition to the &quot;Please fix&quot; button, Tricorder also provides a &quot;Not useful&quot; button that reviewers or proposers can click to express that they do not like the analysis finding. Clicking automatically files a bug in the issue tracker, routing it to the team that owns the analyzer. The Tricorder team tracks such not-useful clicks, computing the ratio of &quot;Please fix&quot; vs. &quot;Not useful&quot; clicks. If the ratio for an analyzer goes above 10%, the Tricorder team disables the analyzer until the author(s) improve it. While the Tricorder team has rarely had to permanently disable an analyzer, it has disabled an analyzer (on several occasions) while the analyzer author is removing and revising sub-checks that were particularly noisy.</p>
<p>The bugs being filed often lead to improvement in the analyzers that in turn greatly improves developers' satisfaction with those analyzers; for example, the Error Prone team developed, in 2014, an Error Prone check that flagged when too many arguments were being passed to a <code>printf</code>-like function in Guava.<sup><a href="#R19">19</a></sup> The <code>printf</code>-like function did not actually accept all <code>printf</code> specifiers, accepting only %s. About once per week the Error Prone team would receive a &quot;Not useful&quot; bug claiming the analysis was incorrect because the number of format specifiers in the bug filers' code matched the number of arguments passed. In every case, the analysis was correct, and the user was trying to pass specifiers other than %s. The team thus changed the diagnostic text to state directly that the function accepts only the %s placeholder and stopped getting bugs filed about that check.</p>
<hr align="center" width="50%" />
<blockquote>
<p align="center"><i>Even in a mature codebase with full test coverage and a rigorous code-review process, bugs slip by.</i></p>
</blockquote>
<hr align="center" width="50%" />
<p><i>Scale of Tricorder.</i> As of January 2018, Tricorder had analyzed approximately 50,000 code review changes per day. During peak hours, there were three analysis runs per second. Reviewers clicked &quot;Please Fix&quot; more than 5,000 times per day, and authors applied the automated fixes approximately 3,000 times per day. And Tricorder analyzers received &quot;Not useful&quot; clicks 250 times per day.</p>
<p>The success of code-review analysis suggests it occupies a &quot;sweet spot&quot; in the developer workflow at Google. Analysis results that are shown at compilation time must reach a much higher bar for quality and accuracy that is not possible to meet for some analyses that can still identify serious faults. After the review and code are checked in, the friction confronting developers for making changes increases. Developers are thus hesitant to make additional changes to code that has already been tested and released, and lower severity and less-important issues are unlikely to be addressed. Other analysis projects among major software-development organizations (such as Facebook Infer analysis for Android/iOS apps<sup><a href="#R7">7</a></sup>) have also highlighted code review as a key point for reporting analysis results.</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<a name="body-6"></a>
<h3>Expand Analyzer Reach</h3>
<p>As Google developer-users have gained trust in the results from Tricorder analyzers, they continue to request further analyses. Tricorder addresses this in two ways: allowing project-level customization and adding analysis results at additional points in the developer workflow. In this section, we also touch on the reasons Google does not yet leverage more sophisticated analysis techniques as part of its core developer workflow.</p>
<p><b>Project-level customization.</b> Not all requested analyzers are equally valuable throughout the Google codebase; for example, some analyzers are associated with higher false-positive rates and so would have correspondingly high effective false-positive rates or require specific project configuration to be useful. These analyzers all have value but only for the right team.</p>
<p>To satisfy these requests, we aimed to make Tricorder customizable. Our previous experience with customization for FindBugs did not end well; user-specific customization caused discrepancies within and across teams and resulted in declining use of tools. Because each user could see a different view of issues, there was no way to ensure a particular issue was seen by everyone working on a project. If developers removed all unused imports from their team's code, the fix would quickly backslide if even a single other developer was not consistent about removing unused imports.</p>
<p>To avoid such problems, Tricorder allows configuration only at the project level, ensuring that anyone making a change to a particular project sees a consistent view of the analysis results relevant to that project. Maintaining a consistent view has enabled several types of analyzers to do the following:</p>
<p><i>Produce dichotomous results.</i> For example, Tricorder includes an analyzer for protocol buffer definitions<sup><a href="#R33">33</a></sup> that identifies changes that are not backward compatible. It is used by developer teams that ensure persistent information from protocol buffers in their serialized form but is annoying for teams that do not store data in this form. Another example is an analyzer that suggests using Guava<sup><a href="#R37">37</a></sup> or Java 7 idioms that do not make sense for projects that cannot use these libraries or language features;</p>
<p><i>Need a particular setup or in-code annotations.</i> For example, teams can only use the Checker Framework's nullness analysis<sup><a href="#R9">9</a></sup> if their code is annotated appropriately. Another analysis, when configured, will check the increase in binary size and method count for a particular Android binary and warn developers if there is a significant increase or if they are approaching a hard limit;</p>
<p><i>Support custom domain-specific languages (DSLs) and team-specific coding guidelines.</i> Some Google software development teams have developed small DSLs with associated validators they wish to run. Other teams have developed their own best practices for readability and maintainability and would like to enforce those checks; and</p>
<p><i>Are highly resource-intensive.</i> An example is hybrid analyses that incorporate results from dynamic analysis. Such analyses provide high value for some teams but are too costly or slow for all.</p>
<p>As of January 2018, there were approximately 70 optional analyses available within Google, and 2,500 projects had enabled at least one of them. Dozens of teams across the company are actively developing a new analyzer, most outside the developer-tools group.</p>
<p><b>Additional workflow integration points.</b> As developers have gained trust in the tools, they have also requested further integration into their workflow. Tricorder now provides analysis results through a command-line tool, a continuous integration system, and a code-browsing tool.</p>
<p><i>Command line support.</i> The Tricorder team added command-line support for developers who are, in effect, code janitors, regularly going through and scrubbing their team's codebase of various analysis warnings. These developers are also very familiar with the types of fixes each analysis will generate and have high trust in specific analyzers. Developers can thus use a command-line tool to automatically apply all fixes from a given analysis and generate cleanup changes;</p>
<p><i>Gating commits.</i> Some teams want specific analyzers to actually block commits, rather than just appear in the code-review tool. The ability to block commits is commonly requested by teams that have highly specific custom checks with no false positives, usually for a custom DSL or library; and</p>
<p><i>Results in code browsing.</i> Code browsing works best for showing the scale of a problem across a large project (or an entire codebase). For example, analysis results when browsing code about a deprecated API can show how much work a migration entails; or some security and privacy analyses are global in scope and require specialized teams to vet the results before determining whether there is indeed a problem. Since analysis results are not displayed by default, the code browser allows specific teams to enable an analysis layer and then scan the entire codebase and vet the results without disrupting other developers with distractions from these analyzers. If an analysis result has an associated fix, then developers can apply the fix with a single click from the code-browsing tool. The code browser is also ideal for displaying results from analyses that utilize production data, as this data is not available until code is committed and running.</p>
<p><b>Sophisticated analyses.</b> All of the static analyses deployed widely at Google are relatively simple, although some teams work on project-specific analysis frameworks for limited domains (such as Android apps) that do interprocedural analysis. Interprocedural analysis at Google scale is technically feasible. However, implementing such an analysis is very challenging. All of Google's code resides in a single monolithic source code repository, as discussed, so, conceptually, any code in the repository can be part of any binary. It is thus possible to imagine a scenario in which analysis results for a particular code review would require analyzing the entire repository. Although Facebook's Infer<sup><a href="#R7">7</a>,<a href="#R25">25</a></sup> focuses on compositional analysis in order to scale separation-logic-based analysis to multimillion-line repositories, scaling such analysis to Google's multibillion-line repository would still take significant engineering effort.</p>
<p>As of January 2018, implementing a system to do more sophisticated analyses has not been a priority for Google since:</p>
<p><i>Large investment.</i> The up-front infrastructure investment would be prohibitive;</p>
<p><i>Work needed to reduce false-positive rates.</i> Analysis teams would have to develop techniques to dramatically reduce false-positive rates for many research analyzers and/or severely restrict which errors are displayed, as with Infer;</p>
<p><i>Still more to implement.</i> Analysis teams still have plenty more &quot;simple&quot; analyzers to implement and integrate; and</p>
<hr align="center" width="50%" />
<blockquote>
<p align="center"><i>Engineers working on static analysis must demonstrate impact through hard data.</i></p>
</blockquote>
<hr align="center" width="50%" />
<p><i>High upfront cost.</i> We have found the utility of such &quot;simple&quot; analyzers to be high, a core motivation of FindBugs.<sup><a href="#R24">24</a></sup> In contrast, even determining the cost-benefit ratio for more complicated checks has a high up-front cost.</p>
<p>Note this cost-benefit analysis may be very different for developers outside of Google working in specialized fields (such as aerospace<sup><a href="#R13">13</a></sup> and medical devices<sup><a href="#R21">21</a></sup>) or on specific projects (such as device drivers<sup><a href="#R4">4</a></sup> and phone apps<sup><a href="#R7">7</a></sup>).</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<a name="body-7"></a>
<h3>Lessons</h3>
<p>Our experience attempting to integrate static analysis into Google's workflow taught us valuable lessons:</p>
<p><i>Finding bugs is easy.</i> When a codebase is large enough, it will contain practically any imaginable code pattern. Even in a mature codebase with full test coverage and a rigorous codereview process, bugs slip by. Sometimes the problem is not obvious from local inspection, and sometimes bugs are introduced by seemingly harmless refactorings. For example, consider the following code snippet hashing a field <code>f</code> of type <code>long</code></p>
<blockquote>
<p><code>result = 31 * result + (int) (f ^ (f &gt;&gt;&gt; 32));</code></p>
</blockquote>
<p>Now consider what happens if the developer changes the type of <code>f</code> to <code>int.</code> The code continues to compile, but the right shift by 32 becomes a no-op, the field is XORed with itself, and the hash for the field becomes a constant 0. The result is <code>f</code> no longer affects the value produced by the hashCode method. The right shift by more than 31 is statically detectable by any tool able to compute the type of <code>f</code>, yet we fixed 31 occurrences of this bug in Google's codebase while enabling the check as a compiler error in Error Prone.</p>
<p>Since finding bugs is easy,<sup><a href="#R24">24</a></sup> Google uses simple tooling to detect bug patterns. Analysis writers then tune the checks based on results from running over Google code.</p>
<p><i>Most developers will not go out of their way to use static analysis tools.</i> Following in the footsteps of many commercial tools, Google's initial implementation of FindBugs relied on engineers choosing to visit a central dashboard to see the issues found in their projects, though few of them actually made such a visit. Finding bugs in checked-in code (that may already be deployed and running without user-visible problems) is too late. To ensure that most or all engineers see static-analysis warnings, analysis tools must be integrated into the workflow and enabled by default for everyone. Instead of providing bug dashboards, projects like Error Prone extend the compiler with additional checks, and surface analysis results in code review.</p>
<p><i>Developer happiness is key.</i> In our experience and in the literature, many attempts to integrate static analysis into a software-development organization fail. At Google, there is typically no mandate from management that engineers use static analysis tools. Engineers working on static analysis must demonstrate impact through hard data. For a static analysis project to succeed, developers must feel they benefit from and enjoy using it.</p>
<p>To build a successful analysis platform, we have built tools that deliver high value for developers. The Tricorder team keeps careful accounting of issues fixed, performs surveys to understand developer sentiment, makes it easy to file bugs against the analysis tools, and uses all this data to justify continued investment. Developers need to build trust in analysis tools. If a tool wastes developer time with false positives and low-priority issues, developers will lose faith and ignore results.</p>
<p><i>Do not just find bugs, fix them.</i> To sell a static analysis tool, a typical approach is to enumerate a significant number of issues that are present in a codebase. The intent is to influence decision makers by indicating a potential ability to correct the underlying bugs or prevent them in the future. However, that potential will remain unrealized if developers are not incentivized to act. This is a fundamental flaw: analysis tools measure their utility by the number of issues they identify, while integration attempts fail due to the low number of bugs actually fixed or prevented. Instead, Google static analysis teams take responsibility for fixing, as well as finding, bugs, and measure success accordingly. Focusing on fixing bugs has ensured that tools provide actionable advice<sup><a href="#R30">30</a></sup> and minimize false positives. In many cases, fixing bugs is as easy as finding them through automated tooling. Even for difficult-to-fix issues, research over the past five years has highlighted new techniques for automatically creating fixes for static analysis issues.<sup><a href="#R22">22</a>,<a href="#R28">28</a>,<a href="#R31">31</a></sup></p>
<p><i>Crowdsource analysis development.</i> Although typical static analysis tools require expert developers to write the analyses, experts may be scarce and not actually know what checks will have the greatest impact. Moreover, analysis experts are typically not domain experts (such as those working with APIs, languages, and security). With FindBugs integration, only a small number of Googlers understood how to write new checks, so the small BugBot team had to do all the work themselves. This limited the velocity of adding new checks and prevented others from contributing their domain knowledge. Teams like Tricorder now focus on lowering the bar to developer-contributed checks, without requiring prior static analysis experience. For example, the Google tool Refaster<sup><a href="#R37">37</a></sup> allows developers to write checks by specifying example before and after code snippets. Since contributors are frequently motivated to contribute after debugging faulty code themselves, new checks are biased toward those that save developer time.</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<a name="body-8"></a>
<h3>Conclusion</h3>
<p>Our most important insight is that careful developer workflow integration is key for static analysis tool adoption. While tool authors may believe developers should be delighted by a list of probable defects in code they have written, in practice we did not find such a list motivates developers to fix the defects. As analysis-tool developers, we must measure our success in terms of defects corrected, not the number presented to developers. This means our responsibility extends far beyond the analysis tool itself.</p>
<p>We advocate for a system focused on pushing workflow integration as early as possible. When possible, checks are enabled as compiler errors. To avoid breaking builds, tool writers take on the task of first fixing all the existing issues in the codebase, allowing us to &quot;ratchet&quot; the quality of Google's codebase one small step at a time, without regressions. Since we present the errors in the compiler, developers encounter them immediately after writing code, while they are still amenable to making changes. To enable this, we have developed infrastructure for running analyses and producing fixes over the whole vast Google codebase. We also benefit from code review and submission automation that allows a change to hundreds of files, as well as an engineering culture in which changes to legacy code are typically approved because improving the code wins over risk aversion.</p>
<p>Code review is a sweet spot for displaying analysis warnings before code is committed. In order to ensure developers are receptive to analysis results, Tricorder presents issues only when a developer is changing the code in question, before the change is committed, and the Tricorder team applies a set of criteria to selecting what warnings to display. Tricorder further gathers user data in the code-review tool that is used to detect any analyses that produce unacceptable numbers of negative reactions. The Tricorder team minimizes effective false positives by disabling misbehaving analyses.</p>
<p>To overcome warning blindness, we have worked to regain the trust of Google engineers, finding Google developers have a strong bias to ignore static analysis, and any false positives or poor reporting give them a justification for inaction. Analysis teams are quite careful to enable a check as an error or warning only after vetting it against the criteria described here, so developers are rarely inundated, confused, or annoyed by analysis results. Surveys and feedback channels are an important quality control for this process. Now that developers have gained trust in analysis results, the Tricorder team is fulfilling requests for more analyses surfaced in more locations in the Google developer workflow.</p>
<p>We have built a successful static analysis infrastructure at Google that prevents hundreds of bugs per day from entering the Google codebase, both at compiletime and during code reviews. We hope others can benefit from our experience to successfully integrate static analyses into their own workflows.</p>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<div id="article-references">
<a name="references"></a>
<h3 class="known-headings">References</h3>
<p><a name="R1"></a>1. Aftandilian, E., Sauciuc, R., Priya, S., and Krishnan, S. Building useful program analysis tools using an extensible compiler. In <i>Proceedings of the International Working Conference on Source Code Analysis and Manipulation</i> (Riva del Garda, Italy, Sept. 2324). IEEE Computer Society Press, 2012, 1423.</p>
<p><a name="R2"></a>2. Ayewah, N., Hovemeyer, D., Morgenthaler, J.D., Penix, J., and Pugh, W. Using static analysis to find bugs. <i>IEEE Software 25</i>, 5 (Sept.-Oct. 2008), 2229.</p>
<p><a name="R3"></a>3. Ayewah, N. and Pugh, W. The Google FindBugs fixit. In <i>Proceedings of the International Symposium on Software Testing and Analysis</i> (Trento, Italy, July 1216). ACM Press, New York, 2010.</p>
<p><a name="R4"></a>4. Ball, T., Bounimova, E., Cook, B., Levin, V., Lichtenberg, J., McGarvey, C., Ondrusek, B., Rajamani, S.K., and Ustuner, A. Thorough static analysis of device drivers <i>ACM SIGOPS Operating Systems Review 40</i>, 4 (Oct. 2006), 7385.</p>
<p><a name="R5"></a>5. Bazel; <a href="http://www.bazel.io">http://www.bazel.io</a></p>
<p><a name="R6"></a>6. Bessey, A., Block, K., Chelf, B., Chou, A., Fulton, B., Hallem, S., Henri-Gros, C., Kamsky, A., McPeak, S., and Engler, D. A few billion lines of code later. <i>Commun. ACM 53</i>, 2 (Feb. 2010), 6675.</p>
<p><a name="R7"></a>7. Calcagno, C., Distefano, D., Dubreil, J., Gabi, D., Hooimeijer, P., Luca, M., O'Hearn, P.W., Papakonstantinou, I., Purbrick, J., and Rodriguez, D. Moving fast with software verification. In <i>Proceedings of the NASA Formal Method Symposium</i> (Pasadena, CA, Apr. 2729). Springer, 2015.</p>
<p><a name="R8"></a>8. Chambers, C., Raniwala, A., Perry, F., Adams, S., Henry, R., Bradshaw, R., and Weizenbaum, N. FlumeJava: Easy, efficient data-parallel pipelines. In <i>Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation</i> (Toronto, Canada, June 510). ACM Press, New York, 2010.</p>
<p><a name="R9"></a>9. The Checker Framework; <a href="https://checkerframework.org">https://checkerframework.org</a></p>
<p><a name="R10"></a>10. Checkstyle Java Linter; <a href="http://checkstyle.sourceforge.net/">http://checkstyle.sourceforge.net/</a></p>
<p><a name="R11"></a>11. Clang Thread Safety Analysis; <a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html">http://clang.llvm.org/docs/ThreadSafetyAnalysis.html</a></p>
<p><a name="R12"></a>12. ClangTidy; <a href="https://clang.llvm.org/extra/clang-tidy.html">http://clang.llvm.org/extra/clang-tidy.html</a></p>
<p><a name="R13"></a>13. Cousot, P., Cousot, R., Feret, J., Mauborgne, L., Min&eacute;, A., Monniaux, D., and Rival, X. The ASTR&Eacute;E analyzer. In <i>Proceedings of the European Symposium on Programming</i> (Edinburgh, Scotland, Apr. 210). Springer, Berlin, Heidelberg, 2005.</p>
<p><a name="R14"></a>14. Dynamic Sanitizer Tools; <a href="https://github.com/google/sanitizers">https://github.com/google/sanitizers</a></p>
<p><a name="R15"></a>15. Error Prone; <a href="http://errorprone.info">http://errorprone.info</a></p>
<p><a name="R16"></a>16. FindBugs; <a href="http://findbugs.sourceforge.net/">http://findbugs.sourceforge.net/</a></p>
<p><a name="R17"></a>17. Go vet; <a href="https://golang.org/cmd/vet">https://golang.org/cmd/vet</a></p>
<p><a name="R18"></a>18. Golint; <a href="https://github.com/golang/lint">https://github.com/golang/lint</a></p>
<p><a name="R19"></a>19. Grammatech; <a href="https://resources.grammatech.com/medical">https://resources.grammatech.com/medical</a></p>
<p><a name="R20"></a>20. Griesmayer, A., Bloem, R., Cook, B. Repair of Boolean programs with an application to C. In <i>Proceedings of the 18<sup>th</sup> International Conference on Computer Aided Verification</i> (Seattle, WA, Aug. 1720). Springer, Berlin, New York, 2006.</p>
<p><a name="R21"></a>21. Guava: Google Core Libraries for Java 1.6+; <a href="https://code.google.com/p/guava-libraries/">https://code.google.com/p/guava-libraries/</a></p>
<p><a name="R22"></a>22. Gupta, P., Ivey, M., and Penix, J. Testing at the speed and scale of Google. <i>Google Engineering Tools Blog</i>, 2011; <a href="https://google-engtools.blogspot.com/2011/06/testing-at-speed-and-scale-of-google.html">http://google-engtools.blogspot.com/2011/06/testing-at-speed-and-scale-of-google.html</a></p>
<p><a name="R23"></a>23. Hacker News. Twitter outage report, 2016; <a href="https://news.ycombinator.com/item?id=8810157">https://news.ycombinator.com/item?id=8810157</a></p>
<p><a name="R24"></a>24. Hovemeyer, D. and Pugh, W. Finding bugs is easy. <i>ACM SIGPLAN Notices 39</i>, 12 (Dec. 2004), 92106.</p>
<p><a name="R25"></a>25. Infer; <a href="http://fbinfer.com/">http://fbinfer.com/</a></p>
<p><a name="R26"></a>26. Johnson, B., Song, Y., Murphy-Hill, E.R., and Bowdidge, R.W. Why don't software developers use static analysis tools to find bugs? In <i>Proceedings of the 35<sup>th</sup> International Conference on Software Engineering</i> (San Francisco, CA, May 1826). ACM Press, New York, 2013.</p>
<p><a name="R27"></a>27. Klein, D.V., Betser, D.M., and Monroe, M.G. Making 'push on green' a reality: Issues and actions involved in maintaining a production service. <i>;login: 39</i>, 5 (2014), 2632.</p>
<p><a name="R28"></a>28. Kneuss, E., Koukoutos, M., and Kuncak, V. Deductive program repair. In <i>Proceedings of the 27<sup>th</sup> International Conference on Computer Aided Verification</i> (San Francisco, CA, July 1824). Springer, 2015.</p>
<p><a name="R29"></a>29. Larus, J.R., Ball, T., Das, M., DeLine, R., Fahndrich, M., Pincus, J., Rajamani, S.K., and Venkatapathy, R. Righting software. <i>IEEE Software 21</i>, 3 (May 2004), 92100.</p>
<p><a name="R30"></a>30. Lewis, C., Lin, Z., Sadowski, C., Zhu, X., Ou, R., and Whitehead, Jr., E. J. Does bug prediction support human developers' findings?: From a Google case study. In <i>Proceedings of the 35<sup>th</sup> International Conference on Software Engineering</i> (San Francisco, CA, May 1826). ACM Press, New York, 2013.</p>
<p><a name="R31"></a>31. Logozzo, F. and Ball, T. Modular and verified automatic program repair. <i>ACM SIGPLAN Notices 46</i>, 10 (Oct. 19, 2012), 133146.</p>
<p><a name="R32"></a>32. Potvin, R. and Levenburg, J. Why Google stores billions of lines of code in a single repository. <i>Commun. ACM 59</i>, 7 (July 2016), 7887.</p>
<p><a name="R33"></a>33. Protocol buffers; <a href="https://code.google.com/p/protobuf/">http://code.google.com/p/protobuf/</a></p>
<p><a name="R34"></a>34. Pylint Python Linter; <a href="http://www.pylint.org/">http://www.pylint.org/</a></p>
<p><a name="R35"></a>35. Sadowski, C., van Gogh, J., Jaspan, C., S&ouml;derberg, E., and Winter, C. Tricorder: Building a program analysis ecosystem. In <i>Proceedings of the 37<sup>th</sup> International Conference on Software Engineering</i> (Firenze, Italy, May 1624). ACM Press, New York, 2015.</p>
<p><a name="R36"></a>36. Synopsys Editorial Team. <i>Coverity Report on the 'Goto Fail' Bug.</i> Blog post, Synopsys, Mountain View, CA, Feb. 25, 2014; <a href="http://security.coverity.com/blog/2014/Feb/a-quick-post-on-apple-security-55471-aka-goto-fail.html">http://security.coverity.com/blog/2014/Feb/a-quick-post-on-apple-security-55471-aka-goto-fail.html</a></p>
<p><a name="R37"></a>37. Wasserman, L. Scalable, example-based refactorings with Refaster. In <i>Proceedings of the Workshop on Refactoring Tools</i> (Indianapolis, IN, Oct. 26). ACM Press, New York, 2013.</p>
<p><a name="R38"></a>38. Wright, H., Jasper, D., Klimek, M., Carruth, C., and Wan, Z. Large-scale automated refactoring using ClangMR. In <i>Proceedings of the 29<sup>th</sup> IEEE International Conference on Software Maintenance</i> (Eindhoven, the Netherlands, Sept. 2228). IEEE Computer Society Press, 2013.</p>
</div>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<div id="article-authorinfo">
<a name="authorinfo"></a>
<h3 class="known-headings">Authors</h3>
<p><b>Caitlin Sadowski</b> (<a href="mailto:supertri@google.com">supertri@google.com</a>) is a software engineer at Google Inc., Mountain View, CA, USA.</p>
<p><b>Edward Aftandilian</b> (<a href="mailto:eaftan@google.com">eaftan@google.com</a>) leads the Java compiler and static analysis team at Google, Inc., Mountain View, CA, USA.</p>
<p><b>Alex Eagle</b> (<a href="mailto:alexeagle@google.com">alexeagle@google.com</a>) is a software engineer at Google Inc., Mountain View, CA, USA.</p>
<p><b>Liam Miller-Cushon</b> (<a href="mailto:cushon@google.com">cushon@google.com</a>) is a software engineer at Google Inc., Mountain View, CA, USA.</p>
<p><b>Ciera Jaspan</b> (<a href="mailto:ciera@google.com">ciera@google.com</a>) is a software engineer at Google Inc., Mountain View, CA, USA.</p>
</div>

<p class="totop"><a href="#PageTop">Back to Top</a></p>

<div id="article-footnotes">
<a name="footnotes"></a>
<h3 class="known-headings">Footnotes</h3>
<p><a name="FNA"></a>a. Google's large open source projects (such as Android and Chrome) use separate infrastructure and their own workflows.</p>
<p><a name="FNB"></a>b. <a href="http://errorprone.info/bugpattern/PreconditionsCheckNotNull">http://errorprone.info/bugpattern/PreconditionsCheckNotNull</a></p>
<p><a name="FNC"></a>c. Although this number was initially chosen by the first author somewhat arbitrarily, it seems to be a sweet spot for developer satisfaction and matches the cutoff for similar systems in other companies.</p>
</div>


<div id="article-permission">
<hr class="Separator" />
<a name="permission"></a>
<p>Copyright held by the authors. Publication rights licensed to ACM.<br /> Request permission to publish from <a href="mailto:permissions@acm.org">permissions@acm.org</a></p>
</div>


<p>The Digital Library is published by the Association for Computing Machinery. Copyright&nbsp;&copy;&nbsp;2018 ACM, Inc.</p>

<div class="clearer"></div>
<hr class="thick" />
<a name="comments"></a>
<div id="ArticleComments">
<span id="CommentHeader">&nbsp;</span>
</div>
<p class="view-all">
No entries found
</p>

</div>
<div class="col3 floatLeft lastCol">
<div class="signInWidget widget">
<span class="signInTitle">Sign In <span class="noTransform">for Full Access</span></span>
<form action="https://cacm.acm.org/login" method="post">
<div class="portaInputSignIn">
<label for="inputUser" class="inField">User Name</label>
<input name="current_member[user]" type="text" id="inputUser" />
</div>
<div class="portaInputSignIn">
<label for="inputPassword" class="inField">Password</label>
<input type="password" name="current_member[passwd]" id="inputPassword" />
</div>
<a href="/accounts/forgot-password" class="subText">&raquo; Forgot Password?</a>
<a href="/accounts/new" class="subText"><strong>&raquo; Create an ACM Web Account</strong></a>
<button type="submit" class="submitSignIn">Sign In</button>
</form>
</div>
<div id="article-contents-widget" class="widget contentsWidget">
<h6 class="loud">Article Contents:</h6>
<li class="miniWidgetItem"><a href="#body-1">Introduction</a></li>
<li class="miniWidgetItem"><a href="#body-2">Key Insights</a></li>
<li class="miniWidgetItem"><a href="#body-3">What We Learned from FindBugs</a></li>
<li class="miniWidgetItem"><a href="#body-4">Make It a Compiler Workflow</a></li>
<li class="miniWidgetItem"><a href="#body-5">Warn During Code Review</a></li>
<li class="miniWidgetItem"><a href="#body-6">Expand Analyzer Reach</a></li>
<li class="miniWidgetItem"><a href="#body-7">Lessons</a></li>
<li class="miniWidgetItem"><a href="#body-8">Conclusion</a></li>
<li class="miniWidgetItem"><a href="#references">References</a></li>
<li class="miniWidgetItem"><a href="#authorinfo">Authors</a></li>
<li class="miniWidgetItem"><a href="#footnotes">Footnotes</a></li>
</div>
<div id='SideColumn'>

<div id="related-news-opinion-widget" class="blueWidget widget noBottom">
<span class="widgetName">More News &amp; opinions</span>
<a class="singleNews firstNews" href="/news/247291-ai-removes-unwanted-objects-from-photos">
<h5>
<a href="/news/247291-ai-removes-unwanted-objects-from-photos">AI Removes Unwanted Objects From Photos</a>
</h5>
<span class="dateNews">New Scientist</span>
</a>
<a class="singleNews" href="/magazines/2021/1/249452-insights-for-ai-from-the-human-mind">
<h5>
<a href="/magazines/2021/1/249452-insights-for-ai-from-the-human-mind">Insights for AI from the Human Mind</a>
</h5>
<span class="dateNews">Gary Marcus, Ernest Davis</span>
</a>
<a class="singleNews" href="/blogs/blog-cacm/249954-superb-historical-robots">
<h5>
<a href="/blogs/blog-cacm/249954-superb-historical-robots">Superb Historical Robots</a>
</h5>
<span class="dateNews">Herbert Bruderer</span>
</a>
</div>
<div class="widget resourcesWidget" properties="">
<div class="widgetBigTitle">
<span class="bigTitle">ACM Resources</span>
</div>
<div class="singleBest">
<h5><a href="https://pd.acm.org/ek_courses.cfm?crs=82160" target="_blank">Microsoft Office PowerPoint 2007: Level 2 (Second Edition)<span class="iconNewPage">    </span></a></h5>
<span class="dateNews">Courses</span>
</div>
</div>

</div>
</div>
<a class=" hidden video-link" href=" "></a>
</section>
<button class="to-top"></button>
<footer>
<nav>
<ul>
<li class="first-child"><a href="/about-communications/author-center" title="For Authors">For Authors</a></li>
<li><a href="http://www.acm-media.org/" title="For Advertisers" target="_blank">For Advertisers <img src="/images/icons/new_page.png" alt="For Advertisers" /></a></li>
<li><a href="/privacy" title="Privacy Policy">Privacy Policy</a></li>
<li><a href="/help" title="Help">Help</a></li>
<li><a href="/about-communications/contact-us" title="Contact Us">Contact Us</a></li>
<li><a class="toggle-mobile" href='https://m-cacm.acm.org/magazines/2018/4/226371-lessons-from-building-static-analysis-tools-at-google/fulltext?mobile=true' data-domain='cacm.acm.org'>Mobile Site</a></li>
</ul>
</nav>
<span id="footerText">Copyright &#169; 2021 by the ACM. All rights reserved.</span>
</footer>
</div>
</div>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
<script src="/javascripts/lib/jquery.jplayer.js"></script>
<!--[if lte IE 6]><script type="text/javascript" src="/javascripts/iepngfix_tilebg.js"></script><![endif]-->
<script>!window.jQuery && document.write('<script src="/javascripts/jquery/jquery.min.js"><\/script>')</script>
<script src="/javascripts/jquery.infieldlabel.min.js"></script>
<script src="/javascripts/cufon.js"></script>
<script src="/javascripts/proxima_400.font.js"></script>
<script src="/javascripts/behaviors/jquery.tipsy.js"></script>
<script src="/javascripts/behaviors/jquery.colorbox-min.js"></script>
<script src="/javascripts/application.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-6995646-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-6995646-3');
</script>
</body>
</html>
